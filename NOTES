################################################################
#
# Decisions

* Port names are scoped to the component instance

################################################################
#
# To do

o autogenerated component instance names should be decided by the
  component instance itself, with a fallback to the system's
  generic generate_component_name which produces "adder3" or
  "constant1" or whatever.  This would allow the adders to get generic
  names, but the constants' names could embed their constant values,
  say "constant5_1".

################################################################
#
# New component types

o Like select and distribute, only with n inputs and take an integer
  control; if the control input is i then select the ith input
  (output) and if it is out of range always select the nth.

o Relations (=, >, etc.)

o Boolean operators (&&, ||, etc.)

  o What about short-circuiting?  Consider a short-circuiting &&. See
    note below about short-circuiting select and distribute.

o Alternating merge: contains a two-valued state.  It alternately
  takes tokens from its left and right inputs.  If the next-scheduled
  input is empty, it blocks.  (Similarly n-way version of this.)

o Alternating split: Similarto alternating merge, but with one input
  and two outputs.

o The existing merge always prefers input0.  We could have a variation
  that always selects at random, or one that alternates which is
  preferred.

################################################################
#
# Think about

o Separate the runtime environment (the system, including the
  component instances and all the token queues) from the build-time
  environment (including the component specification library).

o There needs to be a way to specify the input and output line names
  instead of having to write garbage like:

        - con5 - frac[input0]

  when it should at the very least be

        - con5 - frac[dividend]

  Question: does this *define* the name of the connection?  I don't
  think so because each handler assigns certain semantics to
  particular names.  For example the divider has inputs named dividend
  and divisor and they are not the same!  So to use the component you
  have to now the port names and their meanings.

  In some cases you may not care which port you use, as for example
  with

        - in - add - out

  where we don't care which input port is used (addend0 or addend1 I
  guess) and there is only one output port.

o Need an abbreviation for

        - con5 - frac[input0]
        - frac[output0] - mul

  Presumably:

        - con5 - frac[input0,output0] - mul

  will do.  When the component has only one input or one output we can
  omit the unambiguous one:

        - con5 - frac[input0] - mul

  This could be ambiguous is there is both an input port named input0
  and a unique output port also named input0.  I thought this wasn't a
  big deal until I started to combine this with the previous section
  where you are _also_ allowed to omit the port name if you don't care
  which one.  But there is still only a problem if the `input0` can be
  understood as both an input and an output port, which I am willing
  to disregard.

  But to do all this there needs to be some way for the parser to
  query the component about what its port names are.

o Consider the 'distribute' which has inputs named 'control' and
  'input'. Suppose you write

        - con5 - distribute

   You didn't say which input port to use.  Is this an error, or does
   it assume that you want an arbitrary port named /^input/, since you
   didn't specify?

   Presumably to get the control port you have to say so explicitly:

        - comparator - distribute[control]

o More generally, components need a better API.

  o The gui is going to need it.

o Tokens could have an associated type, and token queues and component
  ports could have an associated (possibly polymorphic) type.  We can
  do type inference.  For example, the inputs and outputs of the adder
  are integers.  (Or maybe `Num a => a` !)  The control input of
  "select" is a boolean, but its two other inputs and its output are
  type (\forall a. a).

o With select and distribute there seem to be two ways they could
  work.  Consider select, which has three inputs, called control,
  in_t, and in_f.  The select component examines the token on its
  control input, and then selects and outputs the token on in_t if the
  control token is true, and on in_f if the control token is false.
  When does it unblock?

    1.  Only when all three inputs are available.

    2.  It peeks at the control token without reading it.  Then if the
        correct one of in_f or in_t is available, it dequeues the
        control token and the appropriate input token, leaving the
        other input token unread.

  On can ask the dual question about distribute and its output
  queues.  Does it unblock only when both outputs are ready?

  (2) requires a new "peeking" option, which would be a significant
  departure.  But there may be certain kinds of tasks for which it is
  required.  For example, suppose in_t is saturated and control is
  also saturated with true tokens.  But if in_f is empty, the tokens
  and the component train producing them are all blocked.

  * For now, we're going with choice (1).

  o Note that if we did (2) we could have a short-circuiting && and
    ||.  Consider &&.  It has input0 and input1.  When a token becomes
    available on input0 it wakes up and peeks at the token.  If the
    token is false, it consumes the token and outputs false.
    Otherwise the token is true and it goes to sleep until a token is
    available on input1.  At that point it consumes both inputs and
    emits their logical and.

    Not clear that this is actually useful, but it is interesting.

    Could it be built from a lazy select somehow?

o Eventually you need a compiler that translates ordinary expressions
  and conventional control flow constructs into dataflow networks.

################################################################
#
# Systems

* I tried imeplenting an iota function: input one token, sa y3, and
  then it counts up from 3 to infinity.  

    * First I tried diagramming it in Inkscape.  What a pain in the
      ass.  Also, it convinced me that the thing would be nearly
      impossible to do.

    * But then I went ahead and did it anyway and it was really easy
      to write the .df file.  I got it right on the first try.

      Is this the way this is really going to go?

      Maybe I would have had more trouble if I hadn't tried to draw
      the diagram first.

    * But as you realized in 1991, you are going to need an
      abstraction mechanism.  You don't want to have to define 8
      components and 9 wires every time you want an iota.  You want

      : define iota { ... }
      * counter: iota 3

    o Also maybe components like split and merge should issue warnings
      if you don't connect enough inputs or outputs.

        
