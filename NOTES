################################################################
#
# Decisions

* Port names are scoped to the component instance

################################################################
#
# To do

o autogenerated component instance names should be decided by the
  component instance itself, with a fallback to the system's
  generic generate_component_name which produces "adder3" or
  "constant1" or whatever.  This would allow the adders to get generic
  names, but the constants' names could embed their constant values,
  say "constant5_1".

################################################################
#
# Think about

o Separate the runtime environment (the system, including the
  component instances and all the token queues) from the build-time
  environment (including the component specification library).

o There needs to be a way to specify the input and output line names
  instead of having to write garbage like:

        - con5 - frac[input0]

  when it should at the very least be

        - con5 - frac[dividend]

  Question: does this *define* the name of the connection?  I don't
  think so because each handler assigns certain semantics to
  particular names.  For example the divider has inputs named dividend
  and divisor and they are not the same!  So to use the component you
  have to now the port names and their meanings.

  In some cases you may not care which port you use, as for example
  with

        - in - add - out

  where we don't care which input port is used (addend0 or addend1 I
  guess) and there is only one output port.

o Need an abbreviation for

        - con5 - frac[input0]
        - frac[output0] - mul

  Presumably:

        - con5 - frac[input0,output0] - mul

  will do.  When the component has only one input or one output we can
  omit the unambiguous one:

        - con5 - frac[input0] - mul

  This could be ambiguous is there is both an input port named input0
  and a unique output port also named input0.  I thought this wasn't a
  big deal until I started to combine this with the previous section
  where you are _also_ allowed to omit the port name if you don't care
  which one.  But there is still only a problem if the `input0` can be
  understood as both an input and an output port, which I am willing
  to disregard.

  But to do all this there needs to be some way for the parser to
  query the component about what its port names are.

o More generally, components need a better API.

  o The gui is going to need it.

o With select and distribute there seem to be two ways they could
  work.  Consider select, which has three inputs, called control,
  in_t, and in_f.  The select component examines the token on its
  control input, and then selects and outputs the token on in_t if the
  control token is true, and on in_f if the control token is false.
  When does it unblock?

    1.  Only when all three inputs are available.

    2.  It peeks at the control token without reading it.  Then if the
        correct one of in_f or in_t is available, it dequeues the
        control token and the appropriate input token, leaving the
        other input token unread.

  On can ask the dual question about distribute and its output
  queues.  Does it unblock only when both outputs are ready?

  (2) requires a new "peeking" option, which would be a significant
  departure.  But there may be certain kinds of tasks for which it is
  required.  For example, suppose in_t is saturated and control is
  also saturated with true tokens.  But if in_f is empty, the tokens
  and the component train producing them are all blocked.
